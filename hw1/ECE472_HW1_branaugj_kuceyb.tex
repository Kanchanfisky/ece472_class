\documentclass[letterpaper,10pt,titlepage]{article}

\usepackage{graphicx}                                        
\usepackage{amssymb}                                         
\usepackage{amsmath}                                         
\usepackage{amsthm}                                          

\usepackage{alltt}                                           
\usepackage{float}
\usepackage{color}
\usepackage{url}

%\usepackage{balance}
%\usepackage[TABBOTCAP, tight]{subfigure}
%\usepackage{enumitem}
\usepackage{pstricks, pst-node}

\usepackage{geometry}
\geometry{textheight=9in, textwidth=6.5in}

%random comment

\newcommand{\cred}[1]{{\color{red}#1}}
\newcommand{\cblue}[1]{{\color{blue}#1}}

\usepackage{hyperref}
\usepackage{geometry}

\def\name{Jacob Branaugh, Brenn Kucey}

%% The following metadata will show up in the PDF properties
\hypersetup{
  colorlinks = true,
  urlcolor = black,
  pdfauthor = {\name},
  pdfkeywords = {cs472 ``computer architecture'' clements ``chapter 1''},
  pdftitle = {CS 472: Homework 1},
  pdfsubject = {CS 472: Homework 1},
  pdfpagemode = UseNone
}

\begin{document}
\hfill \name

\hfill \today

\hfill CS 472 HW 1

\begin{enumerate}
\item[$(1.3)$] We said that the pattern of $1$s and $0$s used to represent an instruction
  in a computer has no intrinsic meaning. Why is this so and what is the implication of
  this statement?
\item[\textbullet] This is so because the base 2 numbering system is something created by humans, and
	thus has no meaning in the physical world. Because of this, it is up to whoever
	designs the hardware to determine which combinations of bits correspond to which
	instructions. The implication here is that the creator of the hardware and
	instructions ultimately determines the meaning behind those bits, and that one
	designer's bits will not mean the same thing as another designer's bits.

\item[$(1.5)$] Modify the algorithm used in this chapter to locate the longest run of
  non-consecutive characters in the string.
\item[\textbullet] The new algorithm is fairly similar. The differences are as follows:
\begin{itemize}
	\item[-] The 'if' statement checks if the new digit is different instead of the
		 same
	\item[-] The 'then' statement updates the current run value to the new digit value
\end{itemize}

\item[$(1.8)$] What are the differences between RTL, machine language, assembly language,
  high-level language, and pseudocode?
\begin{itemize}
	\item[-] RTL (Register Transfer Language) shows the flow of data between hardware
		registers. It is an abstract representation of how the states and contents
		of hardware registers change as an instruction is being executed.
	\item[-] Machine code is binary. The $1$s and $0$s represent transistor states,
		$1$ being the 'on' (or conducting) state and $0$ being the 'off' (or non
		conducting) state. This is the lowest level on this list.
	\item[-] Assembly is a language that provides a level of abstraction on top of
		machine language. Each command in assembly directly translates to a
		specific machine language binary pattern, but is much more easily understood by humans.
	\item[-] High level language is any language that can be written for general use
		and compiled to run on a specific hardware using a compiler that provides
		instructions for translating the high level code to machine language for
		the hardware. Examples of this are C and C++.
	\item[-] Pseudocode is not a language, but an abstraction of computing language in
		the general sense. It is simply a description of an algorithm that uses
		general terms to describe the control flow. These general terms can be
		applied to any language. 
\end{itemize}

\item[$(1.12)$]What is the difference between a computer's \textit{architecture} and its
  \textit{organization}?
\item[\textbullet] Architecture is the abstract layout, whereas organization is the
	physical layout. Architecture encompasses how the registers interact, while organization
	encompasses how the registers are physically connected to each other.

\item[$(1.18)$]What is the Von Neumann bottleneck?
\item[\textbullet] The Von Neumann bottleneck is a slow-down that occurs due to the fact
	the each instruction requires two accesses to memory, one for the fetch cycle and
	one for the execute cycle.

\item[$(1.33)$]Is Moore's law a law?
\item[\textbullet] No. Moore's law is the idea that the number of components on a
	integrated circuit doubles every two years. There is nothing dictating that this
	\textbf{has} to happen, but this general trend has been observed for decades.

\end{enumerate}



\end{document}
